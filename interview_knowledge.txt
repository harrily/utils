1. 对于内存管理你有什么看法？
- 动态内存尽量谁申请谁释放，分工明确。避免漏释放和重复释放。
- 对于嵌入式系统，分析最常用的内存大小，优化内存池配置。
- 申请到内存后首先初始化内容。
- 保证指针变量初始化
- 评估调用深度，避免栈溢出。
- 如果内存足够，管理信息时不要过于节省内存，造成效率降低或者代码可读性降低。

2.工作中遇到bug怎么解决的
- 如果问题可以稳定再现， 设置断点确定问题现场
- 对于数据在未知时机被修改（一般是越界）的问题，VC的条件断点很有用。
- 如果问题不可再现需要得到bug产生时的相关数据，log等，进行仔细分析。
- 如果仍然没有进展（没有办法的办法），根据bug现象，在代码里增加log输出，期待下次再发生时能得到有用信息。
- 修改bug时，如果是修改共通代码，一定要慎之又慎，因为系统大时，有很多我们遇见不到的系统之间的联系。最好不要轻易修改共通部分，被使用范围越广的模块越是如此。
- 修改后测试，不但要针对问题是否改好进行测试，还要对相关功能，主要功能进行回归测试。


3、	-、归并排序  时间空间复杂度    √
		归并排序实现的主要实现的原理是由上至下递归的二分原数组，并由下至上递归的合并二分后的子数组，由于每次数组的分裂都需要建立两个新的数组，所以其实归并排序的空间复杂度是较高的，可达O(n)。在这里，可能有些小伙伴会在空间复杂度到底是O(n)还是O(nlogn)之间存在疑惑，因为由代码可以得出归并算法的整个过程会复制logn个大小为n的数组，那为什么空间复杂度不是O(nlogn)呢？原因是程序的执行是在线程栈中，一次方法的调用和返回代表着一个栈帧的入栈和出栈，栈帧出栈后，该栈帧中的临时变量所占用的空间都会得到释放。
		
		时间复杂度：O(n*logn)
			由于递归拆分为子序列的时间复杂度是O(logn )，而进行两个有序数组排序的方法复杂度是O(n), 则该算法的时间复杂度是O(n*logn)
		空间复杂度：O(n)	
		  归并的空间复杂度就是那个临时的数组和递归时压入栈的数据占用的空间：n + logn；所以空间复杂度为: O(n)
	-、快速排序  、时间空间复杂度
		时间复杂度： 最坏情况运行时间是 O(n2)，但期望时间是O(nlogn)
		空间复杂度：  最优的情况下空间复杂度为：O(logn)  ；每一次都平分数组的情况 。  最差的情况下空间复杂度为：O( n )      ；退化为冒泡排序的情况
   
	
	-、二者区别
		快速排序（Quicksort）是对冒泡排序的一种改进。
				通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。
		归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。
		快速排序与归并排序的区别：

			快速排序的时间复杂度是O(nlogn)，但是快速排序是一种不稳定的排序方法，也就是说当有多个相同的值的时候在排序结束的时候它们的相对位置会发生改变。
			归并排序的时间复杂度是O(nlogn)，但是归并排序是一种稳定的排序方法，即相等的元素顺序不会改变，但是相比于快速排序来说归并要申请的空间更大，消耗空间更多。
			
			
-、
	常用的时间复杂度所耗费的时间从小到大依次是：
	O(1) < O(logn) < (n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)
		
4、
	总结： 
		1. Java有几种设计模式，各有什么优缺点，适合什么场景。  √
		2. 怎样在命令行输入一个hadoop命令，调试这个命令的执行情况。
		3. hadoop是怎样实现文件的 put 和 get 操作的。
		4、spring的aop和设计  √
		5、代理    √
		6、rpc

5、abstract
	-、抽象（abstract）的使用
	　　当父类的某些方法不确定时，可以用abstract关键字来修饰该方法[抽象方法]，用abstract来修饰该类[抽象类]。
	　　我们都知道，父类是将子类所共同拥有的属性和方法进行抽取，这些属性和方法中，有的是已经明确实现了的，有的还无法确定，那么我们就可以将其定义成抽象，在后日子类进行重用，进行具体化。这样，抽象类也就诞生了。
	　　例如，定义了“动物”父类，其中“动物名称”和“动物年龄”属性已经明确了，但是“动物叫”的方法没有明确，此时就可以将“动物叫”定义为抽象方法。
	　　所以，抽象类是为了把相同的但不确定的东西的提取出来，为了以后的重用。定义成抽象类的目的，就是为了在子类中实现抽象类。 
		复制代码
		package javastudy;
		public class AbstractDemo1 {
			public static void main(String[] args) {
				// TODO Auto-generated method stub
			}
		}
		// 这就是一个抽象类
		abstract class Animal {
			String name;
			int age;
			// 动物会叫
			public abstract void cry(); // 不确定动物怎么叫的。定义成抽象方法，来解决父类方法的不确定性。抽象方法在父类中不能实现，所以没有函数体。但在后续在继承时，要具体实现此方法。
		}
		// 抽象类可以被继承
		// 当继承的父类是抽象类时，需要将抽象类中的所有抽象方法全部实现。
		class cat extends Animal {
			// 实现父类的cry抽象方法
			public void cry() {
				System.out.println("猫叫:");
			}
		}
	 
	-、用abstract修饰的类，即抽象类；用abstract修饰的方法，即抽象方法。
	-、抽象方法不能有方法主体。格式如下：
		abstract void xxx();
	-、抽象类不能被实例化。因为抽象类中方法未具体化，这是一种不完整的类，所以直接实例化也就没有意义了。
	-、抽象类中不一定要包含abstrace方法。也就是了，抽象中可以没有abstract方法。
	-、一旦类中包含了abstract方法，那类该类必须声明为abstract类。
	
	-、抽象与接口的区别：
	
		抽象类：
			抽象类体现了数据抽象的思想，是实现多态的一种机制。它定义了一组抽象的方法，至于这组抽象方法的具体表现形式由派生类来实现。同时抽象类提供了继承的概念，它的出发点就是为了继承，否则它没有存在的任何意义。所以说定义的抽象类一定是用来继承的，同时在一个以抽象类为节点的继承关系等级链中，叶子节点一定是具体的实现类。 
				在语法方面： 
					1.由abstract关键词修饰的类称之为抽象类。 
					2.抽象类中没有实现的方法称之为抽象方法，也需要加关键字abstract。 
					3.抽象类中也可以没有抽象方法，比如HttpServlet方法。 
					4.抽象类中可以有已经实现的方法，可以定义成员变量。

		接口： 
			接口是用来建立类与类之间的协议，它所提供的只是一种形式，而没有具体的实现。同时实现该接口的实现类必须要实现该接口的所有方法，通过使用implements关键字。 接口是抽象类的延伸，java为了保证数据安全是不能多重继承的，也就是说继承只能存在一个父类，但是接口不同，一个类可以同时实现多个接口，不管这些接口之间有没有关系，所以接口弥补了抽象类不能多重继承的缺陷， 
				语法方面： 
					1.由interface关键词修饰的称之为接口； 
					2.接口中可以定义成员变量，但是这些成员变量默认都是public static final的常量。 
					3.接口中没有已经实现的方法，全部是抽象方法。 
					4.一个类实现某一接口，必须实现接口中定义的所有方法。 
					5.一个类可以实现多个接口。
					6.一个接口不能实现(implements)另一个接口,但它可以继承多个其它的接口

		区别： 
			一.语法层次上：如上所述。 
			二.设计层次上： 
			1、 抽象层次不同。抽象类是对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。 
			2、 跨域不同。抽象类所跨域的是具有相似特点的类，而接口却可以跨域不同的类。我们知道抽象类是从子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可，但是接口不同。实现它的子类可以不存在任何关系，共同之处。例如猫、狗可以抽象成一个动物类抽象类，具备叫的方法。鸟、飞机可以实现飞Fly接口，具备飞的行为，这里我们总不能将鸟、飞机共用一个父类吧！所以说抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在”is-a” 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已,相当于是”like-a”的关系。 
			3、 设计层次不同。对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。所以说抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。

		附加，空接口的作用: 
			通常是作为一个标记，你比如这个Serializable、Cloneable。

5.1、多态 （面向对象其他两大类  封装 + 继承） 
    1-、多态的概念
		多态是方法或对象具有多种形态，是面向对象的第三大特征。
		多态的前提是两个对象（类）存在继承关系，多态是建立在封装和继承基础之上的。
	1.1-、	对象的多态是多态的核心和重点。
		规则：	
			一个对象的编译类型与运行类型可以不一致
			编译类型在定义对象时，就确定了，不能改变，而运行类型是可以变化的
			编译类型看定义对象时 = 号的左边，运行类型看 = 号的右边	
		
	总结就是， 子类重新父类方法。  右边new孩子， 左边是父类 ，  打印的方法是孩子的实现方法。
		//多态形式，创建对象
		//注意编译类型看等号左边，运行类型看等号右边
		Person p1 = new Student();  
		//此时调用的是 Student 类 的 mission() 方法
		p1.mission();
		//多态形式，创建对象
		Person p2 = new Teacher();
		//此时调用的是 Teacher 类 的 mission() 方法
		p2.mission();
		
	2、多态的转型
		2.1 向上转型
				父类类型 引用名 = new 子类类型();
			//右侧创建一个子类对象，把它当作父类看待使用
		2.2 向下转型
				子类类型 引用名 = (子类类型) 父类引用;
			//用强制类型转换的格式，将父类引用类型转为子类引用类型
		
		示例：
			//向上转型（自动类型转换）
			Person p1 = new Student();
			//调用的是 Student 的 mission
			p1.mission(); 
			//向下转型  （强转的是父类的引用)
			Student s1 = (Student)p1;
			//调用的是 Student 的 score
			s1.score();
				
	参考资料：https://blog.csdn.net/m0_67599274/article/details/124314210	
5.1 final  关键字
	1、修饰类，方法，变量
	2、修饰类：	不能被继承（无子类，但可以用父类）
	3、修饰方法：方法不能被重写，但是可以继承
	4、修饰变量：变量为常量，不能被再次赋值。
				 变量为引用类型（类、接口、数组）的变量，则引用变量所指向的对象（即该变量所存放的地址值）不能更改，但是该对象的内容（即地址值上存储的内容）可以更改！！）。
			修饰局部变量：定义的时候可以不赋值，使用的时候，必须初始化。
			修饰成员变量：  3中赋值方式， -、直接赋值 -、方法块赋值 -、构造方法赋值
	
	
6、 super            √
	super关键字也有两种意义：
	–、调用父类的方法
	–、调用父类的构造器
			但是，super并不表示一个指向对象的引用，它只是一个特殊的关键字，用来告诉编译器，现在要调用的是父类的方法。
			就是一个调用父类的所以方法，在父类中实现的，在子类中写个super（）就行了
			
    具体使用方式：
		-、普通的直接引用
				与this类似，super相当于是指向当前对象的父类，这样就可以用super.xxx来引用父类的成员。
		-、子类中的成员变量或方法与父类中的成员变量或方法同名
		
		-、引用构造函数
				super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。
				this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。
				
				示例：
						class Person { 
							public static void prt(String s) { 
							   System.out.println(s); 
							} 
						   
							Person() { 
							   prt("父类·无参数构造方法： "+"A Person."); 
							}//构造方法(1) 
							
							Person(String name) { 
							   prt("父类·含一个参数的构造方法： "+"A person's name is " + name); 
							}//构造方法(2) 
						} 
							
						public class Chinese extends Person { 
							Chinese() { 
							   super(); // 调用父类构造方法（1） 
							   prt("子类·调用父类”无参数构造方法“： "+"A chinese coder."); 
							} 
							
							Chinese(String name) { 
							   super(name);// 调用父类具有相同形参的构造方法（2） 
							   prt("子类·调用父类”含一个参数的构造方法“： "+"his name is " + name); 
							} 
							
							Chinese(String name, int age) { 
							   this(name);// 调用具有相同形参的构造方法（3） 
							   prt("子类：调用子类具有相同形参的构造方法：his age is " + age); 
							} 
							
							public static void main(String[] args) { 
							   Chinese cn = new Chinese(); 
							   cn = new Chinese("codersai"); 
							   cn = new Chinese("codersai", 18); 
							} 
						}
						运行结果：
							父类·无参数构造方法： A Person.
							子类·调用父类”无参数构造方法“： A chinese coder.
							父类·含一个参数的构造方法： A person's name is codersai
							子类·调用父类”含一个参数的构造方法“： his name is codersai
							父类·含一个参数的构造方法： A person's name is codersai
							子类·调用父类”含一个参数的构造方法“： his name is codersai
							子类：调用子类具有相同形参的构造方法：his age is 18

						从本例可以看到，可以用super和this分别调用父类的构造方法和本类中其他形式的构造方法。
						例子中Chinese类第三种构造方法调用的是本类中第二种构造方法，而第二种构造方法是调用父类的，因此也要先调用父类的构造方法，再调用本类中第二种，最后是重写第三种构造方法。

	-、 super和this的异同：
			-、super（参数）：调用基类中的某一个构造函数（应该为构造函数中的第一条语句） 
			-、this（参数）：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句）
			-、super:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名    super.成员函数据名（实参）
			-、this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）
			-、调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。
			-、super()和this()类似,区别是，super()从子类中调用父类的构造方法，this()在同一类内调用其它方法。
			-、super()和this()均需放在构造方法内第一行。
			-、尽管可以用this调用一个构造器，但却不能调用两个。
			-、this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。
			-、this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。
			-、从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。
	
	
	this & super 参考：
	https://www.jb51.net/article/234982.htm
	this关键字的使用。
		（1）this能出现在实例方法和构造方法中；
		（2）this的语法是“this.”和“this()”；
		（3）this不能出现在静态方法中；
		（4）this大部分情况下是可以省略的；
		（5）this.什么时候不能省略呢？
		在区分局部变量和实例变量时不能省略。例如：
		Public void setName(String name){
			this.name = name;
		}
		（6）this()只能出现在构造方法的第一行，通过当前的构造方法去调用“本类”中的对应的构造方法，目的是：代码复用。
		
	super关键字：
		（1）super能出现在实例方法和构造方法中。
		（2）super的语法是“super.”和“super()”。
		（3） super不能出现在静态方法中。
		（4） super大部分情况下是可以省略的。
		（5）super.什么时候不能省略呢？	
			别急，我们想一下this指向的是什么，是当前对象自己。super和this类似，它指向了当前对象自己的父类型特征（也就是继承过来的那些东西）。
			super和this区别是：this可以看做一个引用变量，保存了该对象的地址，是当前对象整体，而super代表的是父类型特征，是子类局部的一些东西，这些继承过来的东西已经在子类里面了，
			你可以输出整体this，但不能输出父类型特征super。因为super指向的东西不是一个整体，没法打印输出。
			System.out.println(this);  //输出this.toString()的值
			System.out.println(super);  //编译报错，需要'.'
			当在子类对象中，子类想访问父类的东西，可以使用“super.”的方式访问。例如：方法覆盖后，子类内部虽然重写了父类的方法，但子类也想使用一下父类的被覆盖的方法，
			此时可以使用“super.”的方式。当子类中出现和父类一样的属性或者方法，此时，你要想去调用父类的那个属性或者方法，此时“super.”不能省略。
			this和super都只能在对象内部使用。
			this代表当前对象本身，super代表当前对象的父类型特征。
			总结：
				“this.”是一个实例对象内部为了区分实例变量和局部变量。
				而“super.”是一个实例对象为了区分是子类的成员还是父类的成员。
			父类有，子类也有，子类想访问父类的，“super.”不能省略。**
		（6）super()只能出现在构造方法的第一行，通过当前的构造方法去调用“父类”中的对应的构造方法，目的是：创建子类对象时，先初始化父类型特征。
			用通俗的话来讲，要想有儿子，得先有父亲。
			
7、ambari 告警： Percent DataNodes With Available Space
		hdfs的数据节点的存储打到上限警告值
		
8、工厂模式：
		-、简单工厂模式
			简单工厂模式不是 23 种里的一种，简而言之，就是有一个专门生产某个产品的类。
			比如下图中的鼠标工厂，专业生产鼠标，给参数 0，生产戴尔鼠标，给参数 1，生产惠普鼠标。
			
		-、工厂方法模式
			工厂模式也就是鼠标工厂是个父类，有生产鼠标这个接口。
			戴尔鼠标工厂，惠普鼠标工厂继承它，可以分别生产戴尔鼠标，惠普鼠标。
			生产哪种鼠标不再由参数决定，而是创建鼠标工厂时，由戴尔鼠标工厂创建。
			后续直接调用鼠标工厂.生产鼠标()即可
			
		-、抽象工厂模式
			抽象工厂模式也就是不仅生产鼠标，同时生产键盘。
			也就是 PC 厂商是个父类，有生产鼠标，生产键盘两个接口。
			戴尔工厂，惠普工厂继承它，可以分别生产戴尔鼠标+戴尔键盘，和惠普鼠标+惠普键盘。
			创建工厂时，由戴尔工厂创建。
			后续工厂.生产鼠标()则生产戴尔鼠标，工厂.生产键盘()则生产戴尔键盘。
			
				在抽象工厂模式中，假设我们需要增加一个工厂，假设我们增加华硕工厂，则我们需要增加华硕工厂，和戴尔工厂一样，继承 PC 厂商。之后创建华硕鼠标，继承鼠标类。创建华硕键盘，继承键盘类即可。
					
			
		总结 ： 只有一个工厂   -->  自己创建工厂生产（多个工厂【mouse】） ，工厂一个行为【创建鼠标】 -->  工厂继续抽想化，工厂多了行为【创建鼠标和键盘】。
	
	
	mvc模式：
			MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。
			Model（模型） - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。
			View（视图） - 视图代表模型包含的数据的可视化。
			Controller（控制器） - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。
		示例：
			我们将创建一个作为模型的 Student 对象。StudentView 是一个把学生详细信息输出到控制台的视图类，StudentController 是负责存储数据到 Student 对象中的控制器类，并相应地更新视图 StudentView。
				MVCPatternDemo，我们的演示类使用 StudentController 来演示 MVC 模式的用法。
				
9、spring mvc
		-、mvc解析流程：
			传统：
				用户 -> 控制器（dispatcherServlet -> handlerMapping -> handlerAdapter[ModelAndView] -> handler [ModelAndView]）-> 模型（service、javaBean、DAO）  -> 视图（viewResovler[（ModelAndView）] -> view）  ->  用户
			优化后：
				用户 <-> 控制器  控制器  <-> 模型  控制器 <-> 视图
			
			
		-、SpringMVC的视图解析流程为： 
			1、调用目标方法，SpringMVC将目标方法返回的String、View、ModelMap或是ModelAndView都转换为一个ModelAndView对象；
			2、然后通过视图解析器（ViewResolver）对ModelAndView对象中的View对象进行解析，将该逻辑视图View对象解析为一个物理视图View对象；
			3、最后调用物理视图View对象的render()方法进行视图渲染，得到响应结果
10、AOP & IOC

		我们是在使用Spring框架的过程中，其实就是为了使用IOC，依赖注入，和AOP，面向切面编程，这两个是Spring的灵魂。

		主要用到的设计模式有工厂模式和代理模式。

		IOC就是典型的工厂模式，通过sessionfactory去注入实例。

		AOP就是典型的代理模式的体现。

		代理模式是常用的java设计模式，他的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。 

		spring的IoC容器是spring的核心，spring AOP是spring框架的重要组成部分。

		在传统的程序设计中，当调用者需要被调用者的协助时，通常由调用者来创建被调用者的实例。但在spring里创建被调用者的工作不再由调用者来完成，因此控制反转（IoC）；创建被调用者实例的工作通常由spring容器来完成，然后注入调用者，因此也被称为依赖注入（DI），依赖注入和控制反转是同一个概念。

		面向方面编程（AOP)是以另一个角度来考虑程序结构，通过分析程序结构的关注点来完善面向对象编程（OOP）。OOP将应用程序分解成各个层次的对象，而AOP将程序分解成多个切面。spring AOP 只实现了方法级别的连接点，在J2EE应用中，AOP拦截到方法级别的操作就已经足够。在spring中，未来使IoC方便地使用健壮、灵活的企业服务，需要利用spring AOP实现为IoC和企业服务之间建立联系。
		IOC:控制反转也叫依赖注入。利用了工厂模式
		将对象交给容器管理，你只需要在spring配置文件总配置相应的bean，以及设置相关的属性，让spring容器来生成类的实例对象以及管理对象。在spring容器启动的时候，spring会把你在配置文件中配置的bean都初始化好，然后在你需要调用的时候，就把它已经初始化好的那些bean分配给你需要调用这些bean的类（假设这个类名是A），分配的方法就是调用A的setter方法来注入，而不需要你在A里面new这些bean了。
		注意：面试的时候，如果有条件，画图，这样更加显得你懂了.

		AOP:面向切面编程。（Aspect-Oriented Programming）
		AOP可以说是对OOP的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。
		将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面，然后注入到目标对象（具体业务逻辑）中去。

		实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码.

		简单点解释，比方说你想在你的biz层所有类中都加上一个打印‘你好’的功能,这时就可以用aop思想来做.你先写个类写个类方法，方法经实现打印‘你好’,然后Ioc这个类 ref＝“biz.*”让每个类都注入即可实现。

		 

		Spring面试，IoC和AOP的理解
		spring 的优点？
		1.降低了组件之间的耦合性 ，实现了软件各层之间的解耦 
		2.可以使用容易提供的众多服务，如事务管理，消息服务等 
		3.容器提供单例模式支持 
		4.容器提供了AOP技术，利用它很容易实现如权限拦截，运行期监控等功能 
		5.容器提供了众多的辅助类，能加快应用的开发 
		6.spring对于主流的应用框架提供了集成支持，如hibernate，JPA，Struts等 
		7.spring属于低侵入式设计，代码的污染极低 
		8.独立于各种应用服务器 
		9.spring的DI机制降低了业务对象替换的复杂性 
		10.Spring的高度开放性，并不强制应用完全依赖于Spring，开发者可以自由选择spring的部分或全部 

		什么是DI机制？ 
		依赖注入（Dependecy Injection）和控制反转（Inversion of Control）是同一个概念，具体的讲：当某个角色 
		需要另外一个角色协助的时候，在传统的程序设计过程中，通常由调用者来创建被调用者的实例。但在spring中 
		创建被调用者的工作不再由调用者来完成，因此称为控制反转。创建被调用者的工作由spring来完成，然后注入调用者 
		因此也称为依赖注入。 
		spring以动态灵活的方式来管理对象 ， 注入的两种方式，设置注入和构造注入。 
		设置注入的优点：直观，自然 
		构造注入的优点：可以在构造器中决定依赖关系的顺序。 

		什么是AOP？ 
		面向切面编程（AOP）完善spring的依赖注入（DI），面向切面编程在spring中主要表现为两个方面 
		1.面向切面编程提供声明式事务管理 
		2.spring支持用户自定义的切面 

		面向切面编程（aop）是对面向对象编程（oop）的补充， 
		面向对象编程将程序分解成各个层次的对象，面向切面编程将程序运行过程分解成各个切面。 
		AOP从程序运行角度考虑程序的结构，提取业务处理过程的切面，oop是静态的抽象，aop是动态的抽象， 
		是对应用执行过程中的步骤进行抽象，，从而获得步骤之间的逻辑划分。 

		aop框架具有的两个特征： 
		1.各个步骤之间的良好隔离性 
		2.源代码无关性 	

11、代理

		动态代理是一种符合AOP设计思想的技术，那么什么又是AOP?
		代理Proxy：
			Proxy代理模式是一种结构型设计模式，主要解决的问题是：在直接访问对象时带来的问题
			代理是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对象的访问。代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理。		为了保持行为的一致性，代理类和委托类通常会实现相同的接口，所以在访问者看来两者没有丝毫的区别。通过代理类这中间一层，能有效控制对委托类对象的直接访问，也可以很好地隐藏和保护委托类对象，同时也为实施不同控制策略预留了空间，从而在设计上获得了更大的灵活性。
			
		
		好处：
			1.通过反射机制实现动态代理，并且能够代理各种类型的对象
			2、在Java中要想实现动态代理机制，需要java.lang.reflect.InvocationHandler接口和 java.lang.reflect.Proxy 类的支持。实现InvocationHandler接口，必须实现invoke方法。
			由此，那么所有的函数调用最终都会经过invoke函数的转发，因此我们就可以在这里做一些自己想做的操作，比如日志系统、事务、拦截器、权限控制等。这也就是AOP(面向切面编程)的基本原理。
		
10、待办：
		-、Google账号退出
		-、mytest提交至github
		-、退出有道云
		

2022-11-29
11、
