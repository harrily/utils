
1、插入讨论
					55-B 
			   /		    \
		   38 				 80
		 /	  \				/   \
       25-B   46-B       76-B	88-B     
	 /     \    \         /
	17     33    50		 72

				图A
				
				  55-R(55-B) 
			   /		    \
		   38-B 			 80-B 
		 /	  \				/   \
       25-R   46-B       76-B	88-B     
	 /     \    \         /
  17-B   33-B    50		 72
	/			
 10(newNode)	 图B
	
	
					55-B 
			   /		    \
		   38 				 76-B
		 /	  \				/   
       25-B   46-B       72	   
	 /     \    \         
	17     33    50		 
		    
				图1 
			|
			|
		    | 		
		  \ | /
			|

				 55-R(55-B) 
			   /		    \
		   38-B 			 76-B
		 /	  \				/   
       25-R   46-B       72	   
	 /     \    \         
	17-B   33-B  50	
   /
  10(newNode)	
				图2
  
  
  如果插入10 ， uncle 都是Red ， 此时应该上溢操作，  
	1、25从 Black 变为 Red
	   17 ， 33 Red 变为 Black 
	2、 此时25上移动， 相当于newNode，  此时重新判断
	【相当于插入25， 此时  uncle是black (no Red) 。  此时应该应该参考  LL/RR进行处理。】
	按照文章说的，继续上移动， 递归应该判断uncle的颜色后，再决定是上溢操作变色，还是变色+旋转，
		（因为 如果生硬的直接上溢，此时是图1则变为图2 ，则 从根节点到右边叶子  55-76 -72  ,  黑色是 3个，  左边是 4个。  不满足4.）
		代码种递归的时候，上溢时需要判断uncle。
	
	【相当于插入25， 此时  判断uncle是Red 。此时继续上溢操作。】
      如果是 从图A --> 图B ，  此时 满足  右便叶子   55 - 80  - 76 -72  黑色4个， 左边也是4个，满足。
	  
---- >>>>>>插入情况汇总
	 * 	1、插入节点的parent是black，直接插入即可
	 *  2、插入节点的uncle = not Red (black or null)：
	 *  	1-、RR & LL
	 *  		1-、RR情况 :  parent = grandpa.right , newNode = parent.right
	 *  		2-、LL情况:  parent = grandpa.left , newNode = parent.left
	 *  		步骤：
	 *  			1、parent 染为black ， grandPa染为 Red
	 *  			2、grand 进行单旋操作
	 *  				 RR: 左旋 
	 *  		 		 LL: 右旋
	 *  	2-、LR & RL 
	 *  		1-、LR情况:   parent = grandpa.left , newNode = parent.right
	 *		 	2-、RL情况:  parent = grandpa.right , newNode = parent.left
	 *  	  	步骤：
	 *  			1、 插入节点（newNode） 染为 Black , grandPa染为 Red
	 *  			2、双旋转操作:
	 *  				 LR:parent 左旋转， grandpa 右旋转
	 *  				 RL:parent 右旋转， grandpa 左旋转
	 *  3、插入节点的uncle =  Red : 
	 *   LL,RR,LR,RL: 
	 *  	parent、uncle 染成黑色
     *		grand 向上合并
	 *			将向上合并的grand染成红色，相对上一层，就当做是新添加的节点，再次来一遍插入情况的判断，进行处理。
			grand 向上合并时，可能继续发生上溢。这种情况就继续递归调用修复方法就可以了。若上溢持续到根节点，只需将根节点染成黑色即可
			（这个意思就是说断向上上溢，一直上溢到了B树的根节点位置了，只需要将向上合并的节点变成黑色作为红黑树的根节点即可。因为从B树根节点选择出来上溢的节点，肯定就是作为整个红黑树的根节点了）。
			
			备注： 每次向上的节点granpd ， 应该要判断，是否uncle为Red
					1、如果uncle为Red ，则  变色即可
					2、如果uncle为Black or null ,则应该参考  LL/RR进行处理。
	 *  		
	 
	 参考资料“： https://blog.csdn.net/weixin_37607613/article/details/123973818
	 https://www.zhihu.com/question/312327402	  
 
2、删除
-----> 删除讨论 --> 自己整理。不完善， 完善参考 资料： https://www.jianshu.com/p/84416644c080
	1-、删除节点， 没有子节点
			-、删除节点为红色 ，直接删除
			-、删除节点为黑色， 《删除平衡操作。》
								-、parent=红色 （此时uncle必为黑，uncle右子树必为nil 或者红色） ， parent左旋/右旋
								-、parent=黑色 ，-- 删除平衡操作。。 
	2-、删除节点， 有一个子节点 。 则删除节点必为黑色。 子节点必为红色，
				-、此时 子节点替换parent节点， 颜色置为parent的颜色。
	3-、删除节点， 有2个子节点，使用后继节点（左侧最大 or 右侧最小）
								-、删除节点为红色 ，左边最大/右边最小， 替换删除节点，赋颜色红色。
								-、删除节点为黑色，左边最大/右边最小， 替换删除节点，赋颜色红色。

参考资料：    https://www.jianshu.com/p/84416644c080

1、删除动作（移除节点）之后，看看这个节点是不是黑色的叶子节点，如果不是，简单处理就可以达到平衡了；
2、先看N是不是根节点，是的话啥都不用管；不是的话看兄弟什么颜色：
	2 兄弟是黑色，看看兄弟子节点是不是全部都是黑。
	（1）全黑的话，看父什么颜色进行对应处理；
	（2）不全黑，看兄在的位置，兄在左的话，看兄的左子是不是红色，进行对应处理；兄在右的话，看兄的右子是不是红色，进行对应处理。
	3 兄弟是红色：进行旋转涂色，去到兄弟为黑色那里处理
	
作者：路过的猪
链接：https://www.jianshu.com/p/84416644c080
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

删除15                         															删除后继节点，变色，旋转。
 * 	            13-B(d)                              15-B(后继节点值替换)           15-B 
 *         /            \                                \                               \
 *       8-B             17-B                          25-B                           25-B
 *     /     \          /     \           -->         /    \          -->           /     \
 *   1-B     11-B     15-B    25-R 			        17-R    27-B                  21-R   27-B
 *      \				    /   \                   /   \                        /     \
 *     6-R                21-B   27-B           15-B(d) 21-B                   17-B    22-B
 *                        /   \                          /    \                   \
 *                      20-R  22-R                     20-R  22-R                 20-R
 *                      
 *       *          满足： 
		
										
删除17   
 * 	            13-B						  13-B
 *         /            \                            \
 *       8-B             17-B                         20-B                         
 *     /     \          /     \           -->         /    \         
 *   1-B     11-B     15-B    25-R 			        15-B    25-R                 
 *      \				    /   \                 		  /   \                      
 *     6-R                21-B   27-B           		 21-B  27-B                  
 *                        /   \                              \              
 *                      20-R  22-R                           22-R          
 *                      
 *       *          满足： 
 
 删除25  -> 找后继						后继节点替换27-B（25-R改为27-R）【2.2.1.1】	 删除后继节点 27-B （兄左， SL为红（SR为红[或者黑也可以]））  
 * 	            13-B						     13-B							13-B
 *         /            \                            \							    \					
 *       8-B             17-B                          17-B                          17-B
 *     /     \          /     \           -->         /    \             -->         /    \
 *   1-B     11-B     15-B    25-R(d)			     15-B  27-R                  15-B     21-R
 *      \				    /   \                 		   /   \                           /   \ 
 *     6-R                21-B   27-B           		 21-B  27-B                     20-B   27-B   
 *                        /   \                          /   \                                 /   \
 *                      20-R  22-R                     20-R  22-R                            22-R  27-B(d)
 *                      
 *       *          满足： 
 
 删除 11  ，【2.2.2.1】[兄左，兄黑，SL为黑（且肯定为nil），SR必须为红（不存在SR为黑，如果为黑，此时应该属于2.1的情况，兄全黑）,]
									
												  S左旋[6-B]，S和SR互换颜色 ，转至2.2.1.1           P右旋（8-B），P和S颜色互换，SL涂黑色，
  * 	        13-B						     	      13-B							      13-B		
 *         /            \                                /						   		     /				
 *       8-B             17-B                         8-B                                  6-B
 *     /     \          /     \           -->         /    \             	-->           /   \
 *   1-B     11-B(d)   15-B    25-R			        6-B  11-B(d)                       1-B    8-B
 *      \				     /   \                 	 /  	                                     \
 *     6-R                21-B   27-B              1-R 	                                         11-B(d)
 *                        /   \                         
 *                      20-R  22-R                   
 
 
删除 1 ，测试 2.2.2.2（前提 删除6，新增11，  构造2,2,2,2的情况）
											   S右旋[11-B] ,S和SL互换颜色 ，转至2.2.1.2       //以 P左旋，P和S颜色互换，SR涂黑色，

  * 	        13-B						     	      13-B							      13-B		
 *         /            \                                /						   		     /				
 *       8-B             17-B                         8-B                                  10-B
 *     /     \          /     \           -->         /    \             	  -->           /   \
 *   1-B(d)  11-B    15-B    25-R			       1-B(d)   10-B                         8-B    11-B
 *           / 		   		 /   \                 	  		    \	                      /        
 *         10-R             21-B   27-B                         11-R 	                1-B(b)                     
 *                        /   \                         
 *                      20-R  22-R          
 
    /**
	 * 		- 构造2.1.1  (兄全黑  ， 父 红 )	
	 *        tree.remove(20, insert);
	 *        tree.remove(22, insert);
	 *        tree.remove(21, insert);
													
														S和P颜色互换	
  * 	        13-B						     	      13-B							     
 *         /            \                               	  \							   		 				
 *       8-B             17-B                                 17-B                            
 *     /     \          /     \           -->         		 /    \             	  
 *   1-B     11-B    15-B    25-R			              15-B    25-B                     
 *      \       		   /    \                 	  		      /    \	                    
 *      6-R              21-B(d) 27-B                         21-B(d)  27-R                                
 *                                                
 */


/**
	测试 2.2.2 (兄全黑  ， 父黑)	
	 *        tree.remove(6, insert);
	 *        tree.remove(1, insert);
										    //此时将S涂红，父节点作为新的平衡节点N，递归上去处理。     处理8-B的平衡 ，转为 2.2.1.2 【兄右，兄黑，SR红】
																										【以p左旋 ，p和s互换颜色，SR涂黑】
 * 	            13-B						             13-B													   17-B 
 *         /            \                             /          \										      /            \
 *       8-B             17-B                        8-B          17-B                                      13-B          25-B
 *     /     \          /     \           -->       /    \           ..    -->   						   /    \          /   \    
 *   1-B(d)  11-B    15-B    25-R 			      1-B(d)  11-R                                          8-B     15-B     21-B   27-B 
 *      				      /   \                 		                                           /   \            /   \ 
 *                         21-B   27-B           		               						       1-B(d)  11-R       20-R  22-R
 *                        /   \                                      
 *                      20-R  22-R                               
 *                      

**/

 
 
 DEMO  测试 2.2.2 -->  2.2.2.1 [兄左，兄黑，SL为黑（且肯定为nil），SR必须为红（不存在SR为黑，如果为黑，此时应该属于2.1的情况，兄全黑）] 
			2.2.2.2  [兄右，兄黑，SR为黑（且肯定为nil），SL必为红（不存在SL为黑，如果为黑，此时应该属于2.1的情况，兄全黑）]
 
	删除70    						2.2.2（兄黑，兄SL为黑，SR为红） ，
							测试按照2.2.1直接右旋 （P和S互换， SL置为黑【SL本来就是黑，不需要动】） ,此时30-R不平衡   ， 故只能先切换至2.2.1后处理。 
    20-B                                    20-B
   / 	\                                 /      \	
 10-B    60-R                           10-B     30-R
		/	 \           -->                         \             
       30-B  70-B(d)                                 60-B 
	     \                                           /   \
     	  40-R                                      40-R  70-B(d)
		  
		  
		  
--、红黑树的性质

红黑树作为了2-3树的实现，基于2-3树去看红黑树的性质就不在是干瘪瘪的约定，也不需要要强行记忆。

性质1. 结点是红色或黑色。（why：为什么节点要区分颜色，红色节点的作用是什么？）
在上面我们已经解释过了，要区分颜色主要是想要在二叉树中来表示出2-3树的双键节点的情况，如果是红色节点，那么表示当前节点与父节点共同组成了2-3数的双键；黑色节点表示二叉树中的普通节点
性质2. 根结点是黑色。（why：为什么根节点必须是黑色）
还是基于红色节点的作用来理解，根节点本身没有父节点，无法组成2-3树双键，所以不可能是红色节点。
性质3. 所有叶子都是黑色。（why）
此处提到的叶子其实是空链接，在上面的图中空连接未画出。
如果不这样的话，红黑树可能会退化成链。
你考虑一条红黑间隔的链，把它从中间提起来变成一个分成两个叉的树，这个树只有两个叶子，也完全可以符合红黑树的定义。
加入NIL，就是为了让每一个路径都差不多长度相等，进而达到平衡的效果
性质4. 从每个叶子到根的所有路径上不能有两个连续的红色结点。(why)
此性质还是基于红色节点的作用来理解，如果出现了两个连续的红色节点，那么与父节点组成了3键的节点，但是这在2-3树实现的左倾红黑树中是不允许的。（在基于2-3-4树实现的红黑树中允许出现3键，但是只能是左右两边各一个红色节点，也不能连续，在后面扩展部分会有讲解）
性质5. 从任一节结点到其每个叶子的所有路径都包含相同数目的黑色结点。(why)
此性质可以基于2-3树的理论模型来理解，因为在红色节点表示与父节点同层高，所以在红黑树中只有黑色节点会贡献树的高度，所以从任一节结点到其每个叶子的所有路径都包含相同数目的黑色结点
性质6. 每次新插入的节点都必须是红色（why）
此性质在百度百科中未出现，但在一些国外网站上有看到，个人觉得对于理解红黑树也有帮助，所以加在了这里；在上面我们已经演示过了2-3树插入键的过程，先插入键值到节点，然后在判断是否需要分裂，因为优先插入建到当前节点组成2-3树的双键或3键，而在红黑树中只有通过使用红色节点与父节点组成2-3树的双键或3键，所以每次新插入的节点都必须是红色。

参考资料： https://segmentfault.com/a/1190000039774810?utm_source=sf-similar-article
https://www.bilibili.com/read/cv12410219/  -- 红黑树和2-3-4树

https://blog.csdn.net/cy973071263/article/details/122543826  红黑树演变成2-3-4详解


--、红黑树的时间复杂度？
	一棵含有n个节点的红黑树的高度至多为2log(n+1)” => 红黑树时间复杂度为O(logn)
	https://blog.csdn.net/qq_38685503/article/details/103433212	
	https://www.codenong.com/cs105703296/
--、所有叶子都是黑色，即nil为什么要定义为黑色，意义在哪里？
	1、如果不这样的话，红黑树可能会退化成链。
你考虑一条红黑间隔的链，把它从中间提起来变成一个分成两个叉的树，这个树只有两个叶子，也完全可以符合红黑树的定义。
加入NIL，就是为了让每一个路径都差不多长度相等，进而达到平衡的效果
	2、强调 NIL 节点为了保证任意一个节点至少有两个分叉
	可以从深度证明中看到 如果我们不引进 NIL 节点 无法得到这样的结论
	
没有nil退化成1条链表              不能是这种两个岔的（此时3-B节点不平衡， 如果有nil ， 从3出发， 有4个路径， 2个路径是3个黑色， 2个路径是2个黑色，不平衡。 
						 如果不加入nil为黑色节点，这个树就平衡了，就退化链表）
   1-B                      3-B                                 5-B  【 带nil节点，按照顺序 546372819插入(会旋转变色)】     【如果不带nil，插入546372819 】
    \                    /       \                           /           \                                                   5-B
	2-R               2-B        4-B                       3-R 		      7-R	 		                                   /      \
       \	          /  \       /  \                      /  \          /  \                                             4-R     6-R     
	  3-B           1-R   nil   nil  5-R                  2-B  4-B      6-B  8-B                                         /           \
	     \                                                /                    \                                        3-B          7-B
	     4-R                                             1-R                  9-R                                       /               \
		    \ 																										   2-R     			8-R
	       5-B                                                                                                         /                   \    
		                                                                                                              1-B                 9-B
	2-B
  /	   \
 1-B   4-B
       /  \ 
	 3-R   5-R  
--、红黑树为什么3次之内旋转就可以平衡
	（1）变色：红黑树的节点由红变黑或由黑变红
	（2）左旋：以 某个节点作为支点（旋转支点），其右子节点变为旋转节点的父节点，右子节点的左子节点变为旋转节点的右子节点，左子节点保持不变。
	（3）右旋：以 某个节点作为支点（旋转支点），其左子节点变为旋转节点的父节点，左子节点的右子节点变为旋转节点的左子节点，右子节点保持不变。
	按照插入和删除的操作。。 插入最多2次旋转达到平衡、删除最多3次旋转达到平衡；所以红黑树最多三次旋转达到平衡
	
	【AVL树和红-黑树都使用“旋转”来保持平衡。AVL树对每个插入操作最多需要一次旋转，对每个删除操作最多需要O(log n)次旋转】
		(4) AVL树删除一个节点，最坏情况下需要logn次旋转才能恢复平衡性质（需要回溯到根节点）。
		插入节点是子树高度加1，旋转会将子树高度减1，因此一次旋转即可恢复平衡；
		删除节点是子树高度减1，旋转可能会将高度再次减1，这可能会触发再次旋转。	
	参考资料：https://www.zhihu.com/question/270669995
	https://zhuanlan.zhihu.com/p/454080520 【avl】
	
-- rb树，和avl树， 的数学归纳法
参考资料：https://zhuanlan.zhihu.com/p/93369069
