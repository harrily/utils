

					55-B 
			   /		    \
		   38 				 80
		 /	  \				/   \
       25-B   46-B       76-B	88-B     
	 /     \    \         /
	17     33    50		 72

				图A
				
				  55-R(55-B) 
			   /		    \
		   38-B 			 80-B 
		 /	  \				/   \
       25-R   46-B       76-B	88-B     
	 /     \    \         /
  17-B   33-B    50		 72
	/			
 10(newNode)	 图B
	
	
					55-B 
			   /		    \
		   38 				 76-B
		 /	  \				/   
       25-B   46-B       72	   
	 /     \    \         
	17     33    50		 
		    
				图1 
			|
			|
		    | 		
		  \ | /
			|

				 55-R(55-B) 
			   /		    \
		   38-B 			 76-B
		 /	  \				/   
       25-R   46-B       72	   
	 /     \    \         
	17-B   33-B  50	
   /
  10(newNode)	
				图2
  
  
  如果插入10 ， uncle 都是Red ， 此时应该上溢操作，  
	1、25从 Black 变为 Red
	   17 ， 33 Red 变为 Black 
	2、 此时25上移动， 相当于newNode，  此时重新判断
	【相当于插入25， 此时  uncle是black (no Red) 。  此时应该应该参考  LL/RR进行处理。】
	按照文章说的，继续上移动， 递归应该判断uncle的颜色后，再决定是上溢操作变色，还是变色+旋转，
		（因为 如果生硬的直接上溢，此时是图1则变为图2 ，则 从根节点到右边叶子  55-76 -72  ,  黑色是 3个，  左边是 4个。  不满足4.）
		代码种递归的时候，上溢时需要判断uncle。
	
	【相当于插入25， 此时  判断uncle是Red 。此时继续上溢操作。】
      如果是 从图A --> 图B ，  此时 满足  右便叶子   55 - 80  - 76 -72  黑色4个， 左边也是4个，满足。
	  
	  
	  
    * 		插入情况汇总
	 * 	1、插入节点的parent是black，直接插入即可
	 *  2、插入节点的uncle = not Red (black or null)：
	 *  	1-、RR & LL
	 *  		1-、RR情况 :  parent = grandpa.right , newNode = parent.right
	 *  		2-、LL情况:  parent = grandpa.left , newNode = parent.left
	 *  		步骤：
	 *  			1、parent 染为black ， grandPa染为 Red
	 *  			2、grand 进行单旋操作
	 *  				 RR: 左旋 
	 *  		 		 LL: 右旋
	 *  	2-、LR & RL 
	 *  		1-、LR情况:   parent = grandpa.left , newNode = parent.right
	 *		 	2-、RL情况:  parent = grandpa.right , newNode = parent.left
	 *  	  	步骤：
	 *  			1、 插入节点（newNode） 染为 Black , grandPa染为 Red
	 *  			2、双旋转操作:
	 *  				 LR:parent 左旋转， grandpa 右旋转
	 *  				 RL:parent 右旋转， grandpa 左旋转
	 *  3、插入节点的uncle =  Red : 
	 *   LL,RR,LR,RL: 
	 *  	parent、uncle 染成黑色
     *		grand 向上合并
	 *			将向上合并的grand染成红色，相对上一层，就当做是新添加的节点，再次来一遍插入情况的判断，进行处理。
			grand 向上合并时，可能继续发生上溢。这种情况就继续递归调用修复方法就可以了。若上溢持续到根节点，只需将根节点染成黑色即可
			（这个意思就是说断向上上溢，一直上溢到了B树的根节点位置了，只需要将向上合并的节点变成黑色作为红黑树的根节点即可。因为从B树根节点选择出来上溢的节点，肯定就是作为整个红黑树的根节点了）。
			
			备注： 每次向上的节点granpd ， 应该要判断，是否uncle为Red
					1、如果uncle为Red ，则  变色即可
					2、如果uncle为Black or null ,则应该参考  LL/RR进行处理。
	 *  		
	 
	 参考资料“： https://blog.csdn.net/weixin_37607613/article/details/123973818
	 https://www.zhihu.com/question/312327402
--、红黑树的性质

红黑树作为了2-3树的实现，基于2-3树去看红黑树的性质就不在是干瘪瘪的约定，也不需要要强行记忆。

性质1. 结点是红色或黑色。（why：为什么节点要区分颜色，红色节点的作用是什么？）
在上面我们已经解释过了，要区分颜色主要是想要在二叉树中来表示出2-3树的双键节点的情况，如果是红色节点，那么表示当前节点与父节点共同组成了2-3数的双键；黑色节点表示二叉树中的普通节点
性质2. 根结点是黑色。（why：为什么根节点必须是黑色）
还是基于红色节点的作用来理解，根节点本身没有父节点，无法组成2-3树双键，所以不可能是红色节点。
性质3. 所有叶子都是黑色。（why）
此处提到的叶子其实是空链接，在上面的图中空连接未画出。
如果不这样的话，红黑树可能会退化成链。
你考虑一条红黑间隔的链，把它从中间提起来变成一个分成两个叉的树，这个树只有两个叶子，也完全可以符合红黑树的定义。
加入NIL，就是为了让每一个路径都差不多长度相等，进而达到平衡的效果
性质4. 从每个叶子到根的所有路径上不能有两个连续的红色结点。(why)
此性质还是基于红色节点的作用来理解，如果出现了两个连续的红色节点，那么与父节点组成了3键的节点，但是这在2-3树实现的左倾红黑树中是不允许的。（在基于2-3-4树实现的红黑树中允许出现3键，但是只能是左右两边各一个红色节点，也不能连续，在后面扩展部分会有讲解）
性质5. 从任一节结点到其每个叶子的所有路径都包含相同数目的黑色结点。(why)
此性质可以基于2-3树的理论模型来理解，因为在红色节点表示与父节点同层高，所以在红黑树中只有黑色节点会贡献树的高度，所以从任一节结点到其每个叶子的所有路径都包含相同数目的黑色结点
性质6. 每次新插入的节点都必须是红色（why）
此性质在百度百科中未出现，但在一些国外网站上有看到，个人觉得对于理解红黑树也有帮助，所以加在了这里；在上面我们已经演示过了2-3树插入键的过程，先插入键值到节点，然后在判断是否需要分裂，因为优先插入建到当前节点组成2-3树的双键或3键，而在红黑树中只有通过使用红色节点与父节点组成2-3树的双键或3键，所以每次新插入的节点都必须是红色。

参考资料： https://segmentfault.com/a/1190000039774810?utm_source=sf-similar-article
https://www.bilibili.com/read/cv12410219/  -- 红黑树和2-3-4树

https://blog.csdn.net/cy973071263/article/details/122543826  红黑树演变成2-3-4详解


--、红黑树的时间复杂度？
