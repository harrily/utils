1、冒泡排序1：
	1-、内层控制交换，左右元素对比，交换
	2-、将最大/小数，慢慢移动至最左侧/最右侧。
	3-、外层循环控制循环次数,内层循环控制左右数对比
    4-、内层for循环，循环次数每次-i（因为外层没循环一次，就有最大/最小的数被找到，内层循环因此每次循环次数 要 -i）
	5-、外层循环可以加flag, 内层循环不存在交换的时候，此时已经拍好了，可以直接跳出外层循环。

	冒泡排序2：
	1-、外层i,每次和内层i+1之后的元素对比， 
	2-、将最大/最小的数据，放在i的位置（每次对比选出当前最大/最小值，放在i）
	

2、选择排序（冒泡排序2的优化版）
	1-、套用冒泡排序2 
	2-、内层循环对比的时候，先不交换位置， 找出最大/最小值后，再交换位置。

3、插入排序
	1-、外层循环i=1,开始， 内层从 i-1开始， j--.  
	2-、内层循环j+1和j对比，交换位置【写法2】， 保证 i之前的数是有序的。（实际上相当于每次循环，保证i之前有序，相当于每次循环在i前插入数，保证插入的数是有序的）
	3-、内层循环的时候可以每次用arr[i]的值与j对比【写法1】，然后交换
			-、如果每次都交换，其实理论上和j+1与j交换一致（因为如果每次都交换，下次的arr[i]的值实际上就是=j+1）
			-、如果不用交换，则只是比较的时候，前者有的arr[i] 和arr[j]对比， 后者是 j+1 和j对比， 因为此时arr[i]的值不等于j+1
				-、如果出现一次arr[i]和arr[j]， 不满足交换条件， 那么后续其实arr[i]和后续的arr[j--]就没必要比较了，因为j--之前的数据已经是有序的。
	4-、排序效果
		[6, 12, 
		[2, 6, 12, 
		[2, 6, 7, 12, 
		[2, 6, 7, 9, 12, 
		[2, 3, 6, 7, 9, 12, 
		[2, 3, 4, 6, 7, 9, 12, 
		[2, 3, 4, 5, 6, 7, 9, 12, 
		[2, 3, 4, 5, 6, 7, 9, 10, 12,
		[2, 3, 4, 5, 6, 7, 8, 9, 10, 12,
		[2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 100, 
		[2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 22, 100]
	
4、快速排序

5、归并排序

6、二分查找