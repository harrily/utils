
<<<<<<HashMap 和 HashSet 即 java 中利用哈希表实现的 Map 和 Set
java 中使用的是哈希桶方式解决冲突的
java 会在冲突链表长度大于一定阈值后，将链表转变为搜索树（红黑树）
java 中计算哈希值实际上是调用的类的 hashCode 方法，进行 key 的相等性比较是调用 key 的 equals 方法。所以如果要用自定义类作为 HashMap 的 key 或者 HashSet 的值，必须重写 hashCode 和 equals 方 法，而且要做到 equals 相等的对象，hashCode 一定是一致的；
hashcode一样，equals不一定一样！
equals一样，hashcode一定一样
————————————————
版权声明：本文为CSDN博主「小轩在不在哟」的文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/xqs196301/article/details/123095920

<<<<<<Hash表定义
Hash，也可以称为“散列”，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。这是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出（也就是多对一的关系）

Hash为什么快？
在所有的线性数据结构中，数组的定位速度最快，因为它可通过数组下标直接定位到相应的数组空间，就不需要一个个查找。而哈希表就是利用数组这个能够快速定位数据的结构解决以上的问题的。
"数组可以通过下标直接定位到相应的空间”，对就是这句，哈希表的做法其实很简单，就是把Key通过一 个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，
取余结果就当作数组的下标，将value存储在以该数字为下标 的数组空间里，而当使用哈希表进行查询的时候，就是再次使用哈希函数将key转换为对应的数组下标，并定位到该空间获取value，
如此一来，就可以充分 利用到数组的定位性能进行数据定位。

参考资料：https://www.cnblogs.com/caopf/p/14692725.html

<<<<<<HashCode 有什么左右？
https://blog.csdn.net/weixin_44364444/article/details/120054230

hashCode:hashcode就是通过hash函数得来的，通俗的说，就是通过某一种算法得到的，hashcode就是在hash表中有对应的位置。
	hashcode代表对象的地址说的是对象在hash表中的位置，物理地址说的对象存放在内存中的地址，
举例；
	hash表中有 hashcode为1、hashcode为2、(…)3、4、5、6、7、8这样八个位置，有一个对象A，A的物理地址转换为一个整数17(这是假如)，就通过直接取余算法，17%8=1，那么A的hashcode就为1，且A就在hash表中1的位置。

作用：1、HashCode的存在主要是为了查找的快捷性，HashCode是用来在散列存储结构中确定对象的存储地址的(后半句说的用hashcode来代表对象就是在hash表中的位置)
	举例：hash表中有1、2、3、4、5、6、7、8个位置，存第一个数，hashcode为1，该数就放在hash表中1的位置，存到100个数字，hash表中8个位置会有很多数字了，1中可能有20个数字，
	存101个数字时，他先查hashcode值对应的位置，假设为1，那么就有20个数字和他的hashcode相同，他只需要跟这20个数字相比较(equals)，
	如果每一个相同，那么就放在1这个位置，这样比较的次数就少了很多，实际上hash表中有很多位置，这里只是举例只有8个，所以比较的次数会让你觉得也挺多的，实际上，如果hash表很大，那么比较的次数就很少很少了。

查找：先通过hashcode来比较，如果hashcode相等，那么就用equals方法来比较两个对象是否相等
	举例：例子说明：上面说的hash表中的8个位置，就好比8个桶，每个桶里能装很多的对象，对象A通过hash函数算法得到将它放到1号桶中，
	当然肯定有别的对象也会放到1号桶中，如果对象B也通过算法分到了1号桶，那么它如何识别桶中其他对象是否和它一样呢，这时候就需要equals方法来进行筛选了。

	即：1、如果两个对象equals相等，那么这两个对象的HashCode一定也相同
		2、如果两个对象的HashCode相同，不代表两个对象就相同，只能说明这两个对象在散列存储结构中，存放于同一个位置
		
		
<<<<<<Hash冲突>>>>>>>
2.1 概念
对于两个数据元素的关键字 和 (i != j)，有 != ，但有：Hash( ) == Hash( )，即：不同关键字通过相同哈希哈数计算出相同的哈希地址，该种现象称为哈希冲突或哈希碰撞。把具有不同关键码而具有相同哈希地址的数据元素称为“同义词”。

2.2 避免
首先，我们需要明确一点，由于我们哈希表底层数组的容量往往是小于实际要存储的关键字的数量的，这就导致一个问题，冲突的发生是必然的，但我们能做的应该是尽量的降低冲突率。
————————————————
版权声明：本文为CSDN博主「小轩在不在哟」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/xqs196301/article/details/123095920

2.3 冲突-避免-哈希函数设计
	1-、引起哈希冲突的一个原因可能是：哈希函数设计不够合理。 哈希函数设计原则：
哈希函数设计的越精妙，产生哈希冲突的可能性就越低，但是无法避免哈希冲突
	2-、所以当冲突率达到一个无法忍受的程度时，我们需要通过降低负载因子来变相的降低冲突率。
已知哈希表中已有的关键字个数是不可变的，那我们能调整的就只有哈希表中的数组的大小。 吧 

2.5 冲突-解决
	2.5.1 闭散列
		闭散列：也叫开放定址法，当发生哈希冲突时，如果哈希表未被装满，说明在哈希表中必然还有空位置，那么可以把key存放到冲突位置中的“下一个” 空位置中去。、、
		1线性探测，next ，  或者 2二次探测。(采用特定公式避免数据紧挨在一起放置)  因此：比散列最大的缺陷就是空间利用率比较低，这也是哈希的缺陷。
	2.5.2 冲突-解决-开散列/哈希桶 （数组+链表）
		开散列法又叫链地址法(开链法)，首先对关键码集合用散列函数计算散列地址，具有相同地址的关键码归于同一子集合，
		每一个子集合称为一个桶，各个桶中的元素通过一个单链表链接起来，各链表的头结点存储在哈希表中。
		2.5 冲突严重时的解决办法
			哈希桶其实可以看作将大集合的搜索问题转化为小集合的搜索问题了，那如果冲突严重，就意味着小集合的搜索性能其实也时不佳的，
				这个时候我们就可以将这个所谓的小集合搜索问题继续进行转化，例如：
		每个桶的背后是另一个哈希表
		每个桶的背后是一棵搜索树

<<<<<<HashMap 和HashTable区别?
1.安全性不同
	hashMap是线程不安全的，在多线程并发环境下，可能会产生死锁等问题，因此需要开发人员自己处理多线程的安全问题。
	hashTable是线程安全的，它的每一个方法上都有synchonized关键字，因此可以直接用多线程中。
2.两者的父类不同                                                      
	hashMap是继承自AbstrctMap类，
	hashtable是继承Dictionary类。
		不过他们都实现了，同时实现了map、Coleable、Serializable这三个接口。
3.对Null的支持不同
	hashTable:key和value都不能为null。如果key为Null只会抛出异常（【因为containsKey方法，中判断key不能为null，如果为null，则containsKey返回为false】），value为Null则需要手动抛出异常。
	hashMap:key可以为Null，但是这样的key只能有一个，因为必须保证key的唯一性；可以有多的key值对应的value值为Null。
5.初始容量大小和每次扩张容量大小不同	
		当已用容量>总容量 * 负载因子
	HashTable ：初始大小 11 ，扩容 = now *2 +1  ，即 new = (old << 2 ) +1 
	HashTable ：初始大小 16 ，扩容  = now *2
6. 计算hash值的方法不同
	HashMap: 是使用自定义的哈希算法
	HashTable： key的hashCode()
7. 数据结构不一样
	1.8后
		HashMap ： 数组+链表 + 红黑树
		HashTable : 数组+链表
8、 HashMap不支持contains(Object value)方法，没有重写toString()方法
	HashTable支持contains(Object value)方法，而且重写了toString()方法

9、 HashMap只支持Iterator遍历
	HashTable支持Iterator和Enumeration两种方式遍历

10、HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。
	所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。
	但这并不是一个一定发生的行为，要看JVM。而Hashtable 则不会。
	备注： 
		fail-fast：
			fail-fast的字面意思是“快速失败”。当我们在遍历集合元素的时候，经常会使用迭代器，但在迭代器遍历元素的过程中，
			如果集合的结构被改变的话，就会抛出ConcurrentModificationException异常（并发修改异常），防止继续遍历【但当次的遍历依旧会遍历完成】。这就是所谓的快速失败机制。
			
			从源码中可以看出，使用了modCount来记录list被修改了几次，expecteModCount记录迭代器对象一开始迭代时修改的次数。
			每次调用next方法的时候，都会对expecteModCount进行检查，
			如果list的modCount与Iterator的expecteModCount次数不一致的话就会抛出ConcurrentModificationException异常。
		
		fail-safe（安全失败）：
			发现遍历的同时其他人来修改，应当能有应对的策略，例如牺牲一定的一致性来让整个遍历完成。例如CopyOnWriteArrayList 。
				原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发ConcurrentModificationException。
				缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。
			场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。
			
		原文链接：https://blog.csdn.net/weixin_43869269/article/details/125339913

原文链接：https://blog.csdn.net/qq_42848910/article/details/107779037
链接：https://www.zhihu.com/question/395019928/answer/1656654366

HashMap 原理 ：https://www.cnblogs.com/chengxiao/p/6059914.html

<<<<<<Hash表 和Tree比较>>>>>>>>

参考资料：https://zhuanlan.zhihu.com/p/34973763

Hash表优点：
	1、查询快。[插入和删除只需要接近0(1)，B树的操作通常需要O(logN)的]
	2、实现方便

	缺点：
	1、扩展性差，需要提前预测数据量的大小
	2、不能有序遍历
	3、Hash在一个桶里面，免不了多次磁盘IO
	4、Hash 索引仅仅能满足"=","IN"和"<=>"查询，不能使用范围查询。
	5、Hash 索引不能利用部分索引键查询。
		对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，
		所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用
	6、Hash 索引在任何时候都不能避免表扫描
		Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。
	7、Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。
		对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。
