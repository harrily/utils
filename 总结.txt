1. 对于内存管理你有什么看法？
- 动态内存尽量谁申请谁释放，分工明确。避免漏释放和重复释放。
- 对于嵌入式系统，分析最常用的内存大小，优化内存池配置。
- 申请到内存后首先初始化内容。
- 保证指针变量初始化
- 评估调用深度，避免栈溢出。
- 如果内存足够，管理信息时不要过于节省内存，造成效率降低或者代码可读性降低。

2.工作中遇到bug怎么解决的
- 如果问题可以稳定再现， 设置断点确定问题现场
- 对于数据在未知时机被修改（一般是越界）的问题，VC的条件断点很有用。
- 如果问题不可再现需要得到bug产生时的相关数据，log等，进行仔细分析。
- 如果仍然没有进展（没有办法的办法），根据bug现象，在代码里增加log输出，期待下次再发生时能得到有用信息。
- 修改bug时，如果是修改共通代码，一定要慎之又慎，因为系统大时，有很多我们遇见不到的系统之间的联系。最好不要轻易修改共通部分，被使用范围越广的模块越是如此。
- 修改后测试，不但要针对问题是否改好进行测试，还要对相关功能，主要功能进行回归测试。


3、	-、归并排序  时间空间复杂度    √
		归并排序实现的主要实现的原理是由上至下递归的二分原数组，并由下至上递归的合并二分后的子数组，由于每次数组的分裂都需要建立两个新的数组，所以其实归并排序的空间复杂度是较高的，可达O(n)。在这里，可能有些小伙伴会在空间复杂度到底是O(n)还是O(nlogn)之间存在疑惑，因为由代码可以得出归并算法的整个过程会复制logn个大小为n的数组，那为什么空间复杂度不是O(nlogn)呢？原因是程序的执行是在线程栈中，一次方法的调用和返回代表着一个栈帧的入栈和出栈，栈帧出栈后，该栈帧中的临时变量所占用的空间都会得到释放。
		
		时间复杂度：O(n*logn)
			由于递归拆分为子序列的时间复杂度是O(logn )，而进行两个有序数组排序的方法复杂度是O(n), 则该算法的时间复杂度是O(n*logn)
		空间复杂度：O(n)	
		  归并的空间复杂度就是那个临时的数组和递归时压入栈的数据占用的空间：n + logn；所以空间复杂度为: O(n)
	-、快速排序  、时间空间复杂度
		时间复杂度： 最坏情况运行时间是 O(n2)，但期望时间是O(nlogn)
		空间复杂度：  最优的情况下空间复杂度为：O(logn)  ；每一次都平分数组的情况 。  最差的情况下空间复杂度为：O( n )      ；退化为冒泡排序的情况
   
	
	-、二者区别
		快速排序（Quicksort）是对冒泡排序的一种改进。
				通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。
		归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。
		快速排序与归并排序的区别：

			快速排序的时间复杂度是O(nlogn)，但是快速排序是一种不稳定的排序方法，也就是说当有多个相同的值的时候在排序结束的时候它们的相对位置会发生改变。
			归并排序的时间复杂度是O(nlogn)，但是归并排序是一种稳定的排序方法，即相等的元素顺序不会改变，但是相比于快速排序来说归并要申请的空间更大，消耗空间更多。
		
4、s
	腾讯Hadoop大数据开发工程师面试回来总结：
	面试题：
	1. Java有几种设计模式，各有什么优缺点，适合什么场景。
	2. 怎样在命令行输入一个hadoop命令，调试这个命令的执行情况。
	3. hadoop是怎样实现文件的 put 和 get 操作的。


