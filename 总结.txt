1. 对于内存管理你有什么看法？
- 动态内存尽量谁申请谁释放，分工明确。避免漏释放和重复释放。
- 对于嵌入式系统，分析最常用的内存大小，优化内存池配置。
- 申请到内存后首先初始化内容。
- 保证指针变量初始化
- 评估调用深度，避免栈溢出。
- 如果内存足够，管理信息时不要过于节省内存，造成效率降低或者代码可读性降低。

2.工作中遇到bug怎么解决的
- 如果问题可以稳定再现， 设置断点确定问题现场
- 对于数据在未知时机被修改（一般是越界）的问题，VC的条件断点很有用。
- 如果问题不可再现需要得到bug产生时的相关数据，log等，进行仔细分析。
- 如果仍然没有进展（没有办法的办法），根据bug现象，在代码里增加log输出，期待下次再发生时能得到有用信息。
- 修改bug时，如果是修改共通代码，一定要慎之又慎，因为系统大时，有很多我们遇见不到的系统之间的联系。最好不要轻易修改共通部分，被使用范围越广的模块越是如此。
- 修改后测试，不但要针对问题是否改好进行测试，还要对相关功能，主要功能进行回归测试。


3、	-、归并排序  时间空间复杂度    √
		归并排序实现的主要实现的原理是由上至下递归的二分原数组，并由下至上递归的合并二分后的子数组，由于每次数组的分裂都需要建立两个新的数组，所以其实归并排序的空间复杂度是较高的，可达O(n)。在这里，可能有些小伙伴会在空间复杂度到底是O(n)还是O(nlogn)之间存在疑惑，因为由代码可以得出归并算法的整个过程会复制logn个大小为n的数组，那为什么空间复杂度不是O(nlogn)呢？原因是程序的执行是在线程栈中，一次方法的调用和返回代表着一个栈帧的入栈和出栈，栈帧出栈后，该栈帧中的临时变量所占用的空间都会得到释放。
		
		时间复杂度：O(n*logn)
			由于递归拆分为子序列的时间复杂度是O(logn )，而进行两个有序数组排序的方法复杂度是O(n), 则该算法的时间复杂度是O(n*logn)
		空间复杂度：O(n)	
		  归并的空间复杂度就是那个临时的数组和递归时压入栈的数据占用的空间：n + logn；所以空间复杂度为: O(n)
	-、快速排序  、时间空间复杂度
		时间复杂度： 最坏情况运行时间是 O(n2)，但期望时间是O(nlogn)
		空间复杂度：  最优的情况下空间复杂度为：O(logn)  ；每一次都平分数组的情况 。  最差的情况下空间复杂度为：O( n )      ；退化为冒泡排序的情况
   
	
	-、二者区别
		快速排序（Quicksort）是对冒泡排序的一种改进。
				通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。
		归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。
		快速排序与归并排序的区别：

			快速排序的时间复杂度是O(nlogn)，但是快速排序是一种不稳定的排序方法，也就是说当有多个相同的值的时候在排序结束的时候它们的相对位置会发生改变。
			归并排序的时间复杂度是O(nlogn)，但是归并排序是一种稳定的排序方法，即相等的元素顺序不会改变，但是相比于快速排序来说归并要申请的空间更大，消耗空间更多。
			
			
-、
	常用的时间复杂度所耗费的时间从小到大依次是：
	O(1) < O(logn) < (n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)
		
4、
	总结：
		1. Java有几种设计模式，各有什么优缺点，适合什么场景。
		2. 怎样在命令行输入一个hadoop命令，调试这个命令的执行情况。
		3. hadoop是怎样实现文件的 put 和 get 操作的。
		4、spring的aop和设计

5、abstract
	-、抽象（abstract）的使用
	　　当父类的某些方法不确定时，可以用abstract关键字来修饰该方法[抽象方法]，用abstract来修饰该类[抽象类]。
	　　我们都知道，父类是将子类所共同拥有的属性和方法进行抽取，这些属性和方法中，有的是已经明确实现了的，有的还无法确定，那么我们就可以将其定义成抽象，在后日子类进行重用，进行具体化。这样，抽象类也就诞生了。
	　　例如，定义了“动物”父类，其中“动物名称”和“动物年龄”属性已经明确了，但是“动物叫”的方法没有明确，此时就可以将“动物叫”定义为抽象方法。
	　　所以，抽象类是为了把相同的但不确定的东西的提取出来，为了以后的重用。定义成抽象类的目的，就是为了在子类中实现抽象类。 
		复制代码
		package javastudy;
		public class AbstractDemo1 {
			public static void main(String[] args) {
				// TODO Auto-generated method stub
			}
		}
		// 这就是一个抽象类
		abstract class Animal {
			String name;
			int age;
			// 动物会叫
			public abstract void cry(); // 不确定动物怎么叫的。定义成抽象方法，来解决父类方法的不确定性。抽象方法在父类中不能实现，所以没有函数体。但在后续在继承时，要具体实现此方法。
		}
		// 抽象类可以被继承
		// 当继承的父类是抽象类时，需要将抽象类中的所有抽象方法全部实现。
		class cat extends Animal {
			// 实现父类的cry抽象方法
			public void cry() {
				System.out.println("猫叫:");
			}
		}
	 
	-、用abstract修饰的类，即抽象类；用abstract修饰的方法，即抽象方法。
	-、抽象方法不能有方法主体。格式如下：
		abstract void xxx();
	-、抽象类不能被实例化。因为抽象类中方法未具体化，这是一种不完整的类，所以直接实例化也就没有意义了。
	-、抽象类中不一定要包含abstrace方法。也就是了，抽象中可以没有abstract方法。
	-、一旦类中包含了abstract方法，那类该类必须声明为abstract类。
	
	-、抽象与接口的区别：
	
		抽象类：
			抽象类体现了数据抽象的思想，是实现多态的一种机制。它定义了一组抽象的方法，至于这组抽象方法的具体表现形式由派生类来实现。同时抽象类提供了继承的概念，它的出发点就是为了继承，否则它没有存在的任何意义。所以说定义的抽象类一定是用来继承的，同时在一个以抽象类为节点的继承关系等级链中，叶子节点一定是具体的实现类。 
				在语法方面： 
					1.由abstract关键词修饰的类称之为抽象类。 
					2.抽象类中没有实现的方法称之为抽象方法，也需要加关键字abstract。 
					3.抽象类中也可以没有抽象方法，比如HttpServlet方法。 
					4.抽象类中可以有已经实现的方法，可以定义成员变量。

		接口： 
			接口是用来建立类与类之间的协议，它所提供的只是一种形式，而没有具体的实现。同时实现该接口的实现类必须要实现该接口的所有方法，通过使用implements关键字。 接口是抽象类的延伸，java为了保证数据安全是不能多重继承的，也就是说继承只能存在一个父类，但是接口不同，一个类可以同时实现多个接口，不管这些接口之间有没有关系，所以接口弥补了抽象类不能多重继承的缺陷， 
				语法方面： 
					1.由interface关键词修饰的称之为接口； 
					2.接口中可以定义成员变量，但是这些成员变量默认都是public static final的常量。 
					3.接口中没有已经实现的方法，全部是抽象方法。 
					4.一个类实现某一接口，必须实现接口中定义的所有方法。 
					5.一个类可以实现多个接口。
					6.一个接口不能实现(implements)另一个接口,但它可以继承多个其它的接口

		区别： 
			一.语法层次上：如上所述。 
			二.设计层次上： 
			1、 抽象层次不同。抽象类是对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。 
			2、 跨域不同。抽象类所跨域的是具有相似特点的类，而接口却可以跨域不同的类。我们知道抽象类是从子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可，但是接口不同。实现它的子类可以不存在任何关系，共同之处。例如猫、狗可以抽象成一个动物类抽象类，具备叫的方法。鸟、飞机可以实现飞Fly接口，具备飞的行为，这里我们总不能将鸟、飞机共用一个父类吧！所以说抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在”is-a” 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已,相当于是”like-a”的关系。 
			3、 设计层次不同。对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。所以说抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。

		附加，空接口的作用: 
			通常是作为一个标记，你比如这个Serializable、Cloneable。

6、 super            √
	super关键字也有两种意义：
	C、调用父类的方法
	C、调用父类的构造器
			但是，super并不表示一个指向对象的引用，它只是一个特殊的关键字，用来告诉编译器，现在要调用的是父类的方法。
			就是一个调用父类的所以方法，在父类中实现的，在子类中写个super（）就行了
			
    具体使用方式：
		-、普通的直接引用
				与this类似，super相当于是指向当前对象的父类，这样就可以用super.xxx来引用父类的成员。
		-、子类中的成员变量或方法与父类中的成员变量或方法同名
		
		-、引用构造函数
				super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。
				this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。
				
				示例：
						class Person { 
							public static void prt(String s) { 
							   System.out.println(s); 
							} 
						   
							Person() { 
							   prt("父类・无参数构造方法： "+"A Person."); 
							}//构造方法(1) 
							
							Person(String name) { 
							   prt("父类・含一个参数的构造方法： "+"A person's name is " + name); 
							}//构造方法(2) 
						} 
							
						public class Chinese extends Person { 
							Chinese() { 
							   super(); // 调用父类构造方法（1） 
							   prt("子类・调用父类”无参数构造方法“： "+"A chinese coder."); 
							} 
							
							Chinese(String name) { 
							   super(name);// 调用父类具有相同形参的构造方法（2） 
							   prt("子类・调用父类”含一个参数的构造方法“： "+"his name is " + name); 
							} 
							
							Chinese(String name, int age) { 
							   this(name);// 调用具有相同形参的构造方法（3） 
							   prt("子类：调用子类具有相同形参的构造方法：his age is " + age); 
							} 
							
							public static void main(String[] args) { 
							   Chinese cn = new Chinese(); 
							   cn = new Chinese("codersai"); 
							   cn = new Chinese("codersai", 18); 
							} 
						}
						运行结果：
							父类・无参数构造方法： A Person.
							子类・调用父类”无参数构造方法“： A chinese coder.
							父类・含一个参数的构造方法： A person's name is codersai
							子类・调用父类”含一个参数的构造方法“： his name is codersai
							父类・含一个参数的构造方法： A person's name is codersai
							子类・调用父类”含一个参数的构造方法“： his name is codersai
							子类：调用子类具有相同形参的构造方法：his age is 18

						从本例可以看到，可以用super和this分别调用父类的构造方法和本类中其他形式的构造方法。
						例子中Chinese类第三种构造方法调用的是本类中第二种构造方法，而第二种构造方法是调用父类的，因此也要先调用父类的构造方法，再调用本类中第二种，最后是重写第三种构造方法。

 
			
	-、 super和this的异同：
			-、super（参数）：调用基类中的某一个构造函数（应该为构造函数中的第一条语句） 
			-、this（参数）：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句）
			-、super:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名    super.成员函数据名（实参）
			-、this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）
			-、调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。
			-、super()和this()类似,区别是，super()从子类中调用父类的构造方法，this()在同一类内调用其它方法。
			-、super()和this()均需放在构造方法内第一行。
			-、尽管可以用this调用一个构造器，但却不能调用两个。
			-、this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。
			-、this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。
			-、从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。
	
7、ambari 告警： Percent DataNodes With Available Space
		hdfs的数据节点的存储打到上限警告值
		
8、工厂模式：
	-、简单工厂模式
		简单工厂模式不是 23 种里的一种，简而言之，就是有一个专门生产某个产品的类。
		比如下图中的鼠标工厂，专业生产鼠标，给参数 0，生产戴尔鼠标，给参数 1，生产惠普鼠标。
		
	-、工厂方法模式
		工厂模式也就是鼠标工厂是个父类，有生产鼠标这个接口。
		戴尔鼠标工厂，惠普鼠标工厂继承它，可以分别生产戴尔鼠标，惠普鼠标。
		生产哪种鼠标不再由参数决定，而是创建鼠标工厂时，由戴尔鼠标工厂创建。
		后续直接调用鼠标工厂.生产鼠标()即可
		
	-、抽象工厂模式
		抽象工厂模式也就是不仅生产鼠标，同时生产键盘。
		也就是 PC 厂商是个父类，有生产鼠标，生产键盘两个接口。
		戴尔工厂，惠普工厂继承它，可以分别生产戴尔鼠标+戴尔键盘，和惠普鼠标+惠普键盘。
		创建工厂时，由戴尔工厂创建。
		后续工厂.生产鼠标()则生产戴尔鼠标，工厂.生产键盘()则生产戴尔键盘。
		
			在抽象工厂模式中，假设我们需要增加一个工厂，假设我们增加华硕工厂，则我们需要增加华硕工厂，和戴尔工厂一样，继承 PC 厂商。之后创建华硕鼠标，继承鼠标类。创建华硕键盘，继承键盘类即可。
				
		
	总结 ： 只有一个工厂   -->  自己创建工厂生产（多个工厂） -->  传入参数，通过抽象方法实现指定某个工厂生产。