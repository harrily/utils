			        8,12
	   3,6           |10                 15,18,20|
1,2 |3,4,5| 6,7|  8,9|10,11  |12,13|15,16,17|18,19|20,21|

	public Node( List<Node> nodes, List<KeyAndValue> keyAndValue, Node nextNode,Node previousNode, Node parantNode) {
18         this.nodes = nodes;
19         this.keyAndValue = keyAndValue;
20         this.nextNode = nextNode;
21         this.parantNode = parantNode;
22         this.previousNode = previousNode;
23     }

参考资料：https://www.cnblogs.com/ll9507/p/11616417.html

定义：
　　一颗m阶B+树满足以下几个条件：
　　1.除根节点外的节点的关键字个数最大为m-1,最小为m/2
　　2.除叶节点外的每个节点的孩子节点的数目为该节点关键字个数加一，这些孩子节点的的关键字的范围与父节点关键字的大小对应（这个看图才看的清楚）
　　3.叶子节点存放着所有的关键字，叶子节点间按关键字的大小用指针相互连接。内部节点以叶子节点的关键字的最小值作为索引
B+树的优势：
　　B+树相较于B树最大的优势在于数据全部都存在于叶子节点，叶子节点间以指针相互连接，这样在进行按照索引的范围查找的时候就只需要遍历前后指针就可以完成，而B树要一个一个索引去进行查找，效率差别很大。
　　B+树相较于hash的优势在于B+树不用一次将数据全部加载到内存，而是先确定要查询索引的地址，将对应的地址的索引加载到内存。而hash需要将全部的数据一次性加载到内存才能完成查找

1、插入操作 
  -、重复值 ，覆盖
  -、判断插入点
	-、从叶子节点出发（head）, 循环遍历node， 找到待插入点。
	-、递归上溢分裂操作（判断带插入点 node是否满足阈值，不满足上溢，如果node有父节点，递归上溢分裂。）
		-、1.1、待插入值所在entry不超过阈值 M-1   ， 直接插入
		-、1.2 、待插入值所在entry超过阈值 M-1 ,  上溢操作。
				1、当前节点根据mid分裂，mid值上溢，
					1、如果mid是叶子保留value，反之只保留key 。
					2、如果mid是叶子 ， 分裂的右节点，从mid+1开始。反之包含mid【即满足 ：内部节点以叶子节点的关键字的最小值作为索引】
				2、维护分裂后的left，right的前后指针 
				3、如果node有孩子，维护孩子的指针
					1、遍历node原孩子，取每个node的 max 值，和新mid的key比较
						1-、max < midkey  , 则此孩子node作为左孩子，即他的父节点为mid分裂出来的left节点。
						20、max >= midKey, 则此孩子node作为右孩子 ，，即他的父节点为mid分裂出来的right节点。
				4、维护（当前node节点的前指针）的指向，前指针的nextNode指向mid分裂出来的left
				5、维护当前node节点的后指针的指向，后指针的前指针指向mid分裂出来的right
				6、维护head指针， 如果当前node是head， 则把mid分裂出的left作为head  head = left
				7、当前节点node是否有parent
					1-、无，维护新的父节点（上溢的mid）与当前left和right的关系。 且把parentNode置为ROOT.
					2-、有，
						-、则在父节点原来孩子的基础上移除oldNode节点，添加分裂出来left，right节点。 
						-、如果父节点有父节点， 则递归调用上溢方法。
					
插入 23之前					
			        8,12
	   3,6           |10                 15,18,20|
1,2 |3,4,5| 6,7|  8,9|10,11  |12,13|15,16,17|18,19|20,21,22|


插入 23之后  
	1、20，21,22， 变为 |20,21,22，23| 分裂 22上溢
	2、22上溢， 15,18,20 变为  15,18,20，22 ,  内存节点分裂， 20上溢 （剔除20，因为不是叶子了此时）
	3、20上溢 ，  8,12  变为  8,12,20  
	
   			     8,            12               ,20
	   3,6 |          |10                  15,18           |    22
1,2 |3,4,5| 6,7|  8,9|10,11       |12,13|15,16,17|18,19    |20,21  |22,23

	
	
