
B+树实现：
	定义， 当前节点keyValue ， 孩子节点nodes,右指针，左指针，父指针。

	public Node( List<Node> nodes, List<KeyAndValue> keyAndValue, Node nextNode,Node previousNode, Node parantNode) {
         this.nodes = nodes;
         this.keyAndValue = keyAndValue;
         this.nextNode = nextNode;
         this.parantNode = parantNode;
         this.previousNode = previousNode;
     }

参考资料：https://www.cnblogs.com/ll9507/p/11616417.html

定义：
　　一颗m阶B+树满足以下几个条件：
　　1.除根节点外的节点的关键字个数最大为m-1,最小为m/2
　　2.除叶节点外的每个节点的孩子节点的数目为该节点关键字个数加一，这些孩子节点的的关键字的范围与父节点关键字的大小对应（这个看图才看的清楚）
　　3.叶子节点存放着所有的关键字，叶子节点间按关键字的大小用指针相互连接。内部节点以叶子节点的关键字的最小值作为索引
B+树的优势：
　　B+树相较于B树最大的优势在于数据全部都存在于叶子节点，叶子节点间以指针相互连接，这样在进行按照索引的范围查找的时候就只需要遍历前后指针就可以完成，而B树要一个一个索引去进行查找，效率差别很大。
　　B+树相较于hash的优势在于B+树不用一次将数据全部加载到内存，而是先确定要查询索引的地址，将对应的地址的索引加载到内存。而hash需要将全部的数据一次性加载到内存才能完成查找

1、插入操作 
  -、重复值 ，覆盖
  -、判断插入点
	-、从叶子节点出发（head）, 循环遍历node， 找到待插入点。
	-、递归上溢分裂操作（判断带插入点 node是否满足阈值，不满足上溢，如果node有父节点，递归上溢分裂。）
		-、1.1、待插入值所在entry不超过阈值 M-1   ， 直接插入
		-、1.2 、待插入值所在entry超过阈值 M-1 ,  上溢操作。
				1、当前节点根据mid分裂，mid值上溢，
					1、如果mid是叶子保留value，反之只保留key 。
					2、如果mid是叶子 ， 分裂的右节点，从mid+1开始。反之包含mid【即满足 ：内部节点以叶子节点的关键字的最小值作为索引】
				2、维护分裂后的left，right的前后指针 
				3、如果node有孩子，维护孩子的指针
					1、遍历node原孩子，取每个node的 max 值，和新mid的key比较
						1-、max < midkey  , 则此孩子node作为左孩子，即他的父节点为mid分裂出来的left节点。
						20、max >= midKey, 则此孩子node作为右孩子 ，，即他的父节点为mid分裂出来的right节点。
				4、维护（当前node节点的前指针）的指向，前指针的nextNode指向mid分裂出来的left
				5、维护当前node节点的后指针的指向，后指针的前指针指向mid分裂出来的right
				6、维护head指针， 如果当前node是head， 则把mid分裂出的left作为head  head = left
				7、当前节点node是否有parent
					1-、无，维护新的父节点（上溢的mid）与当前left和right的关系。 且把parentNode置为ROOT.
					2-、有，
						-、则在父节点原来孩子的基础上移除oldNode节点，添加分裂出来left，right节点。 
						-、如果父节点有父节点， 则递归调用上溢方法。
						
	demo : 

		插入 23之前					
							8,12
			   3,6           |10                 15,18,20|
		1,2 |3,4,5| 6,7|  8,9|10,11  |12,13|15,16,17|18,19|20,21,22|

		插入 23之后  
			1、20，21,22， 变为 |20,21,22，23| 分裂 22上溢
			2、22上溢， 15,18,20 变为  15,18,20，22 ,  内存节点分裂， 20上溢 （剔除20，因为不是叶子了此时）
			3、20上溢 ，  8,12  变为  8,12,20  
			
						 8,            12               ,20
			   3,6 |          |10                  15,18           |    22
		1,2 |3,4,5| 6,7|  8,9|10,11       |12,13|15,16,17|18,19    |20,21  |22,23


2、查询操作
	从root开始 search(key, node)
		1-、key值 < node的最小值 ， 
				-、遍历node的孩子节点， 找到 孩子节点max键 < node的最小值  ，的键值n
					search(key,n)	递归操作
			key > = node的最大值 
				-、遍历node的孩子节点， 找到 孩子节点min键 < node的最大值  ，的键值n
					search(key,n)  递归操作
		2-、key值介于 node的最大和最小值之间
				-、找到node的最窄区间， 根据  i=0 list[i] < = key  && list[i + 1 ] > key  ,  找到 min = i  max = i+1 
				-、遍历node孩子节点， 找到 孩子节点中，  首位>=min && 末尾 < max的键值 n
				search(key,n)  递归操作
		
		3-、如果找到n是叶子节点，找到对应的key的value返回
		

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>跳跃表  <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

4、拓展：回顾跳表-对比B+树

	跳表就能让链表拥有近乎的接近二分查找的效率的一种数据结构，其原理依然是给上面加若干层索引，优化查找速度
		元素： 有序链表 + 索引  + 二分查找 
		
		
	1-、插入操作【插入21 (假设此时 跳表是这样的，-->20   --> 24  )】  
		带插入值为node
			1-、调用search找到最底层的key，如果存在此key，更新value即可。
			2-、从headNode头开始自上而下遍历。
				找到每一层的索引以及最后一层带插入值的前一个节点team 。压栈 （比如此时， 进栈顺序是   9 , 9 , 14 , 19, 20）
				【栈 先进后出， 这样循环方便维护上层的向下索引。】
			3-、循环出栈 【20 ，19 ，14，9, 9】= team  【栈为空，停滞循环】
				直接新建节点 newNode（node.key,node.value）， 
				1、  team的右节点为null
						1-、team.right = newNode 更新team右索引， 
						2-、更新newNode的下索引(初始是null【即最底层】)
				2、	  team的右节点 不为null
						-、 更新带插入节点 newNode 的右索引为原来team的右索引
							更新taem的右索引为 newNode
							更新team.right的downNode，即更新node的下索引(初始为null)。
							更新下一次的downNode值，为newNode（供上一层使用）
				3、判断是否上溢建索引
					1-、 达到层数的阈值，break，跳出while循环
					2-、 掷硬币的方式，判断此次循环是否向上构建newNode的索引。 
							1-、满足，向上构建一层，层数+1 赋值为跳表层数 highLevel，继续循环
							2-、反之，跳出while循环
					3-、如果当前层数 > highLevel （//比当前最大高度要高但是依然在允许范围内 需要改变head节点）
						-、此时高度已经超过跳表的headNode的高度， 如果newNode继续上溢构建索引，则需要新建newHeadNode。
							-、新建 newHeadNode
							-、更新newHeadNode的下索引 
							-、更新HeadNode为 newHeadNode
							-、newHeadNode入栈，继续下次循环（下次循环中，newHeadNode出栈，更新newHeadNode的右节点为，newNode，）
						
				插入21 (假设此时 跳表是这样的，-->20   --> 24  )
			//	    head->                                          9->  
			//	    head->                                          9->  
			//	    head->                 4->                      9->                      14-> 
			//	    head->                 4->                 8->  9->  10->                14->           17->      19-> 
			//	    head->  1->  2->  3->  4->  5->  6->  7->  8->  9->  10-> 11-> 12-> 13-> 14-> 15-> 16-> 17-> 18-> 19->   -->20（team）    --->21  -->  24   
																																			
																																
		
	
	2-、删除操作
		
		
																														
																																
		//// 删除前
		//	    head->                                          9->  
		//	    head->                                          9->  
		//	    head->                 4->                      9->                      14-> 
		//	    head->                 4->                 8->  9->  10->                14->           17->      19-> 
		//	    head->  1->  2->  3->  4->  5->  6->  7->  8->  9->  10-> 11-> 12-> 13-> 14-> 15-> 16-> 17-> 18-> 19->   

		// 删除后（4,8）：
		//	    head->                                9->  
		//	    head->                                9->  
		//	    head->                                9->                      14-> 
		//	    head->                                9->  10->                14->           17->      19-> 
		//	    head->  1->  2->  3->  5->  6->  7->  9->  10-> 11-> 12-> 13-> 14-> 15-> 16-> 17-> 18-> 19-> 

		
		
		 
		
	
