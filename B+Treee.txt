			        8,12
	   3,6           |10                 15,18,20|
1,2 |3,4,5| 6,7|  8,9|10,11  |12,13|15,16,17|18,19|20,21|

	public Node( List<Node> nodes, List<KeyAndValue> keyAndValue, Node nextNode,Node previousNode, Node parantNode) {
18         this.nodes = nodes;
19         this.keyAndValue = keyAndValue;
20         this.nextNode = nextNode;
21         this.parantNode = parantNode;
22         this.previousNode = previousNode;
23     }

参考资料：https://www.cnblogs.com/ll9507/p/11616417.html

定义：
　　一颗m阶B+树满足以下几个条件：
　　1.除根节点外的节点的关键字个数最大为m-1,最小为m/2
　　2.除叶节点外的每个节点的孩子节点的数目为该节点关键字个数加一，这些孩子节点的的关键字的范围与父节点关键字的大小对应（这个看图才看的清楚）
　　3.叶子节点存放着所有的关键字，叶子节点间按关键字的大小用指针相互连接。内部节点以叶子节点的关键字的最小值作为索引
B+树的优势：
　　B+树相较于B树最大的优势在于数据全部都存在于叶子节点，叶子节点间以指针相互连接，这样在进行按照索引的范围查找的时候就只需要遍历前后指针就可以完成，而B树要一个一个索引去进行查找，效率差别很大。
　　B+树相较于hash的优势在于B+树不用一次将数据全部加载到内存，而是先确定要查询索引的地址，将对应的地址的索引加载到内存。而hash需要将全部的数据一次性加载到内存才能完成查找

1、插入操作 
  -、重复值 ，覆盖
  -、判断插入点

	-、1.1、待插入值所在entry不超过阈值 M-1   ， 直接插入
	-、1.2 、待插入值所在entry超过阈值 M-1 ,  上溢操作。
	
	
	
	
	
	
