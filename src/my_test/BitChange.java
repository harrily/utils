package my_test;

import java.util.HashMap;

/**
 *   	位运算
 * @author Administrator
 *
 */
public class BitChange {
   public static void main(String[] args) {
	   int number = 16;
	   //Integer.highestOneBit是用来获取最左边的bit（其他bit位为0）所代表的数值.
	   int highestOneBit = Integer.highestOneBit((number - 1) << 1);
	   System.out.println(highestOneBit);
	   
	   //负数的二进制表示
	   System.out.println(Integer.toBinaryString(-20)); //111111111111111111111111 1110 1100
	   System.out.println(-30 >> 2 );  //-5
	   
	   
	   
	   
	   /**
	    * 
	    * ^( 异或 运算符),按二进制位每个对应为做异或  ----->  两个操作数进行位的异或运算，相同取0，相反取1。即两操作数相同时，互相抵消。
		*	arr[3] ^= arr[2]; 相当于arr[3] = arr[3] ^ arr[2];
		*	本例中arr[3]=5 =(0101)B 二进制
		*	arr[2]=4=(0100)B
		*	0^0=0 1^1=0 0^0=0 1^0=1
		*	(101)^(100)=0001
		*	结果是arr[3]     变为1
	    * 
	    * 
	    * &( 与 运算符)   两个数都转为二进制，然后从高位开始比较，如果两个数都为1则为1，否则为0
	    * 
	    * 
	    * |(或 运算符)  两个数都转为二进制，然后从高位开始比较，两个数只要有一个为1则为1，否则就为0。
	    * 
	    * 
	    * ~ (非运算符)  如果位为0，结果是1，如果位为1，结果是0.
	    * ~37 = -38
	    * 37 转为二进制是100101
		*	补码后为： 00000000 00000000 00000000 00100101
		*	取反为：    11111111 11111111 11111111 11011010
		*	因此，我们可将这个二进制数的补码进行还原： 首先，末尾减1得反码：11111111 11111111 11111111 11011001（（因为高位是1，所以原码为负数，负数的补码是其绝对值的原码取反，末尾再加1。）） 其次，将各位取反得原码：
		*	00000000 00000000 00000000 00100110，此时二进制转原码为38
		*
		*
		* >>>(无符号右移，【正数>>与>>>  一致 】)
		*		res = 20 >> 2; 
		*		20的二进制为 0001 0100，右移2位后为 0000 0101，则结果就为 res = 5;
		*		res = -20 >> 2;
		*		-20的二进制为其正数的补码加1，即 1110 1100，右移2位后为 1111 1011，减1	，转为正数，结果为 res = -5;
		*		而对于>>>符号而言：
		*		res = 20 >>> 2; 的结果与 >> 相同；
		*		res = -20 >>> 2;  //1073741819
		*
	    */
	   
	   
	   
	   
	   HashMap<String,String> map = new HashMap<String,String>();
	   //比如"Aa"和"BB"的hashCode方法返回一致
	   int h = "BB".hashCode() ;
	   System.out.println( (h) ^ (h >>> 16));
   }
   
	  

}
